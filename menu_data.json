document.addEventListener('DOMContentLoaded', () => {
    initApp();
});

const MENU_DATA_URL = 'https://raw.githubusercontent.com/sanmlukk/menu_data.json/refs/heads/main/menu_data.json';

const META_CURRENCY = 'BRL';

function trackMetaEvent(eventName, data) {
    if (typeof fbq === 'function') {
        fbq('track', eventName, data);
    }
}

function getMetaContentId(item) {
    if (!item) return '';
    return item._id || item.id || item.pdvCode || item.sku || item.name || '';
}

function toMetaValue(cents) {
    const value = Number(cents);
    if (!Number.isFinite(value)) return 0;
    return Math.round(value) / 100;
}

function buildMetaContents(items) {
    return (items || []).map(item => ({
        id: getMetaContentId(item),
        quantity: item?.qty || 1
    }));
}

const readCartStorage = () => {
    const readFrom = (storage) => {
        if (!storage) return null;
        try {
            const raw = storage.getItem('cart');
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            return Array.isArray(parsed) ? parsed : null;
        } catch (e) {
            return null;
        }
    };

    let stored = readFrom(localStorage);
    if (!stored) stored = readFrom(sessionStorage);
    if (!stored && window.name) {
        try {
            const parsed = JSON.parse(window.name);
            if (Array.isArray(parsed)) stored = parsed;
        } catch (e) {
            stored = null;
        }
    }

    return stored || [];
};

const writeCartStorage = (nextCart) => {
    const raw = JSON.stringify(nextCart || []);
    try {
        localStorage.setItem('cart', raw);
    } catch (e) {
        // ignore storage errors
    }
    try {
        sessionStorage.setItem('cart', raw);
    } catch (e) {
        // ignore storage errors
    }
    try {
        window.name = raw;
    } catch (e) {
        // ignore storage errors
    }
};

// App State
const state = {
    store: {},
    products: {},
    categories: [],
    bestSellerPaths: [],
    customProducts: {},
    cart: readCartStorage(),
    currentProduct: null,
    currentQty: 1
};

let isNavClicking = false; // Flag to suppress scroll spy during click nav

async function loadMenuData() {
    if (typeof MENU_DATA !== 'undefined') {
        return MENU_DATA;
    }

    if (!MENU_DATA_URL || MENU_DATA_URL.includes('SEU_USUARIO')) {
        alert('Erro: URL do cardÃ¡pio nÃ£o configurada.');
        return null;
    }

    try {
        const cacheBustedUrl = `${MENU_DATA_URL}${MENU_DATA_URL.includes('?') ? '&' : '?'}v=${Date.now()}`;
        const response = await fetch(cacheBustedUrl, { cache: 'no-store' });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('Falha ao carregar menu_data.json:', error);
        alert('Erro: NÃ£o foi possÃ­vel carregar o cardÃ¡pio.');
        return null;
    }
}

async function initApp() {
    const menuData = await loadMenuData();
    if (!menuData) {
        return;
    }

    // Load Data
    const store = menuData.store;
    state.store = store;
    state.categories = store.categories || [];
    state.bestSellerPaths = (store.store && store.store.labeledProductsPath)
        ? store.store.labeledProductsPath
        : (store.labeledProductsPath || []);

    syncBestSellersOverridesWithStore(store);

    // Flatten products map based on structure analysis
    // Usually it is nested, but the key structure "stores/.../products/..." suggests
    // we need to find the object that has these keys.
    // Based on file reading, it seems productsMap is likely directly under `store` or `store.store`. 
    // Let's try to locate it.
    let productsMap = store.productsMap;
    if (!productsMap && store.store && store.store.productsMap) {
        productsMap = store.store.productsMap;
    }

    // Fallback: search for any key that looks like a product map
    if (!productsMap) {
        // Just look for the first object that has keys starting with "stores/"
        for (const key in store) {
            if (typeof store[key] === 'object') {
                const innerKeys = Object.keys(store[key]);
                if (innerKeys.some(k => k.includes('/products/'))) {
                    productsMap = store[key];
                    break;
                }
            }
        }
    }

    state.products = productsMap || {};
    attachProductIds();
    applyCategoryOverrides();
    applyMenuOverrides();
    normalizeBestSellersOverrides();

    // Render Store Info
    renderHeader(store.store || store);
    applyStoreOverrides();

    // Persist store address for checkout page
    const addressEl = document.getElementById('store-address') || document.querySelector('.store-address');
    if (addressEl && addressEl.textContent) {
        localStorage.setItem('storeAddress', addressEl.textContent.trim());
    }

    // Render Categories & Products
    renderCategories();
    renderBestSellers();
    // Pre-calculate logic tags for all products
    tagProductsWithLogic();

    // Render Categories & Products
    renderCategories();
    renderBestSellers();
    renderMenu();

    // Setup Listeners
    setupEventListeners();

    // Open product if URL has a product id
    openProductFromUrl();

    // Show cart footer if there are items stored
    updateCartFooter();
}

function attachProductIds() {
    Object.entries(state.products).forEach(([path, product]) => {
        if (!product || typeof product !== 'object') return;
        if (!product._path) product._path = path;
        if (!product._id) {
            const pathId = path && path.includes('/') ? path.split('/').pop() : null;
            product._id = product.pdvCode || product.id || pathId;
        }
    });
}

function getStoreKey(store) {
    return store?.store?.menuSlug
        || store?.menuSlug
        || store?.store?.uuid
        || store?.uuid
        || store?.store?.id
        || store?.id
        || '';
}

function syncBestSellersOverridesWithStore(store) {
    try {
        const currentKey = getStoreKey(store);
        if (!currentKey) return;

        const lastKey = localStorage.getItem('menuStoreKey');
        if (lastKey && lastKey !== currentKey) {
            localStorage.removeItem('menuBestSellersOverrides');
        }

        localStorage.setItem('menuStoreKey', currentKey);
    } catch (e) {
        // ignore storage errors
    }
}

function getStoreIdFromProductPath(path) {
    if (!path || typeof path !== 'string') return '';
    const parts = path.split('/');
    if (parts.length < 4) return '';
    return parts[0] === 'stores' ? parts[1] : '';
}

function normalizeBestSellersOverrides() {
    try {
        const raw = localStorage.getItem('menuBestSellersOverrides');
        if (!raw) return;

        const data = JSON.parse(raw);
        if (!data || typeof data !== 'object') return;

        const productsKeys = Object.keys(state.products);
        if (productsKeys.length === 0) return;

        const storeId = getStoreIdFromProductPath(productsKeys[0]);
        const validProducts = new Set(productsKeys);
        const isValidPath = (path) => {
            if (!path || typeof path !== 'string') return false;
            if (storeId && !path.startsWith(`stores/${storeId}/products/`)) return false;
            return validProducts.has(path);
        };

        const cleanedPaths = (Array.isArray(data.paths) ? data.paths : []).filter(isValidPath);

        const cleanedCustomItems = (Array.isArray(data.customItems) ? data.customItems : []).filter(entry => {
            const categoryId = entry?.categoryId || entry?.key?.split('::')[0];
            const itemId = entry?.itemId || entry?.key?.split('::')[1];
            if (!categoryId || !itemId) return false;
            const list = state.customProducts?.[categoryId] || [];
            return list.some(item => item.id === itemId);
        });

        if (cleanedPaths.length === 0 && cleanedCustomItems.length === 0) {
            localStorage.removeItem('menuBestSellersOverrides');
            return;
        }

        if (cleanedPaths.length !== (data.paths || []).length || cleanedCustomItems.length !== (data.customItems || []).length) {
            localStorage.setItem('menuBestSellersOverrides', JSON.stringify({
                paths: cleanedPaths,
                customItems: cleanedCustomItems
            }));
        }
    } catch (e) {
        // ignore storage errors
    }
}

function findProductById(productId) {
    if (!productId) return null;
    const products = Object.values(state.products);
    return products.find(product => product && (product._id === productId || product.pdvCode === productId || product.id === productId)) || null;
}

function openProductFromUrl() {
    const params = new URLSearchParams(window.location.search);
    const productId = params.get('product');
    if (!productId) return;
    const product = findProductById(productId);
    if (product) {
        openModal(product);
    }
}

function getShareUrlForProduct(product) {
    if (!product) return null;
    const productId = product._id || product.pdvCode || product.id;
    if (!productId) return null;
    const url = new URL(window.location.href);
    url.searchParams.set('product', productId);
    return url.toString();
}

async function shareCurrentProduct() {
    const url = getShareUrlForProduct(state.currentProduct);
    if (!url) return;

    const title = state.currentProduct?.name || 'Produto';
    try {
        if (navigator.share) {
            await navigator.share({ title, url });
        } else if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(url);
        } else {
            const temp = document.createElement('input');
            temp.value = url;
            document.body.appendChild(temp);
            temp.select();
            document.execCommand('copy');
            temp.remove();
        }
    } catch (e) {
        // ignore share errors
    }
}

function applyStoreOverrides() {
    try {
        const raw = localStorage.getItem('menuStoreOverrides');
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || typeof data !== 'object') return;

        if (data.name) {
            const nameEl = document.getElementById('store-name');
            if (nameEl) nameEl.textContent = data.name;
        }

        if (data.address !== undefined) {
            const addressEl = document.getElementById('store-address') || document.querySelector('.store-address');
            if (addressEl) addressEl.textContent = data.address;
        }

        if (data.hours) {
            const statusEl = document.querySelector('.status-text');
            if (statusEl) statusEl.textContent = data.hours;
        }

        if (data.deliveryTime) {
            const deliveryEl = document.querySelector('.stat-item .stat-value');
            if (deliveryEl) deliveryEl.textContent = data.deliveryTime;
        }

        if (data.logo) {
            const logoEl = document.getElementById('store-logo');
            if (logoEl) logoEl.src = data.logo;
        }

        if (data.banner) {
            const bannerEl = document.querySelector('.banner-image');
            if (bannerEl) bannerEl.src = data.banner;
        }
    } catch (e) {
        console.warn('menuStoreOverrides invÃ¡lido, ignorado.');
    }
}

function applyMenuOverrides() {
    try {
        const raw = localStorage.getItem('menuOverrides');
        if (!raw) return;

        const overrides = JSON.parse(raw);
        if (!overrides || typeof overrides !== 'object') return;

        Object.keys(overrides).forEach(path => {
            const product = state.products[path];
            const patch = overrides[path];
            if (!product || !patch) return;

            if (typeof patch.name === 'string') product.name = patch.name;
            if (typeof patch.description === 'string') product.description = patch.description;
            if (typeof patch.price === 'number') product.price = patch.price;
            if (typeof patch.picture === 'string') product.picture = patch.picture;
        });
    } catch (e) {
        console.warn('menuOverrides invÃ¡lido, ignorado.');
    }
}

function renderHeader(storeInfo) {
    const nameEl = document.getElementById('store-name');
    const logoEl = document.getElementById('store-logo');

    if (nameEl) {
        nameEl.textContent = storeInfo.brand?.name || storeInfo.name || "X Calota";
    }

    // Logo
    // Try to get logo from various possible paths in the data structure
    const logoUrl = storeInfo.logo || storeInfo.place?.logo || storeInfo.brand?.logo;

    if (logoEl && logoUrl) {
        logoEl.src = getImageUrl(logoUrl);
        logoEl.onerror = () => { logoEl.style.display = 'none'; };
    }
}

function renderCategories() {
    const list = document.getElementById('category-list');
    list.innerHTML = '';

    // Add "Mais Pedidos" manually
    const bestSellerLi = document.createElement('li');
    bestSellerLi.className = 'category-item';
    bestSellerLi.textContent = "Mais Pedidos";
    bestSellerLi.dataset.target = "best-sellers-section";
    bestSellerLi.onclick = () => {
        isNavClicking = true;
        const section = document.getElementById('best-sellers-section');
        if (section) {
            const offset = 120;
            const bodyRect = document.body.getBoundingClientRect().top;
            const elementRect = section.getBoundingClientRect().top;
            const elementPosition = elementRect - bodyRect;
            const offsetPosition = elementPosition - offset;
            window.scrollTo({ top: offsetPosition, behavior: 'smooth' });
        }

        document.querySelectorAll('.category-item').forEach(el => el.classList.remove('active'));
        bestSellerLi.classList.add('active');
        setTimeout(() => { isNavClicking = false; }, 2000); // Increased to 2s
    };
    list.appendChild(bestSellerLi);

    state.categories.forEach((cat) => {
        const hasProducts = Array.isArray(cat.productsPaths) && cat.productsPaths.length > 0;
        const customItems = state.customProducts?.[cat.id] || [];
        const hasCustomItems = customItems.length > 0;
        if (!hasProducts && !hasCustomItems && !cat.isCustom) return;

        const li = document.createElement('li');
        li.className = `category-item`;
        li.textContent = cat.name;
        li.dataset.target = `cat-${cat.id}`;
        li.onclick = () => {
            isNavClicking = true;
            scrollToCategory(cat.id);
            document.querySelectorAll('.category-item').forEach(el => el.classList.remove('active'));
            li.classList.add('active');
            setTimeout(() => { isNavClicking = false; }, 2000); // Increased to 2s
        };
        list.appendChild(li);
    });

    setTimeout(updateActiveCategory, 100);
}



function tagProductsWithLogic() {
    state.categories.forEach(cat => {
        if (!cat.productsPaths) return;

        // Base rule: Categories matching Combo/Calota/Calotinha
        const isTargetCat = /Combo|Calota|Calotinha/.test(cat.name);

        cat.productsPaths.forEach(path => {
            const product = state.products[path];
            if (product) {
                let showFrom = isTargetCat;

                // Exclusion List
                const exclusions = [
                    "Calota Cheddar com Fritas + COCA 1L",
                    "Calotinha Frango + Coca 200ML + Fritas 150G",
                    "Calotinha Acebolado + Coca Lata + Maionese branca",
                    "Calota Entreveiro com CoraÃ§Ã£o + COCA 1L",
                    "Calota Mexicano + COCA 1L",
                    "Calota Especial + COCA 1L",
                    "Calota Alcatra 4 Queijos + GUARANÃ 2L",
                    "Calota Pernil SuÃ­no",
                    "Calota Contra FilÃ© Acebolado",
                    "Calotinha Frango c/ Bacon",
                    "Calotinha Contra FilÃ© Acebolado",
                    "Calotinha Pernil suino",
                    "Calotinha Cheddar com Fritas",
                    "Calota Cheddar com Fritas"
                ];

                if (exclusions.some(excluded => product.name.includes(excluded))) {
                    showFrom = false;
                }

                // Assign tags to product object
                // If product already processed (e.g. in multiple cats), OR logic could apply, 
                // but usually first win or consistently true is better. 
                // Here we just overwrite or set if undefined.
                product.showFrom = showFrom;
                product.hasAddons = showFrom; // Add-ons follow same rule
            }
        });
    });
}

function renderMenu() {
    const container = document.getElementById('menu-container');

    state.categories.forEach(cat => {
        const hasProducts = Array.isArray(cat.productsPaths) && cat.productsPaths.length > 0;
        const items = state.customProducts[cat.id] || [];
        if (!hasProducts && items.length === 0 && !cat.isCustom) return;

        const section = document.createElement('section');
        section.id = `cat-${cat.id}`;
        section.className = 'category-section';

        const title = document.createElement('h3');
        title.className = 'category-title';
        title.textContent = cat.name;
        section.appendChild(title);

        if (hasProducts) {
            cat.productsPaths.forEach(path => {
                const product = state.products[path];
                if (product) {
                    // Use pre-calculated tag
                    const card = createProductCard(product, product.showFrom);
                    section.appendChild(card);
                }
            });
        }

        if (items.length > 0) {
            items.forEach(item => {
                const card = createProductCard(item, false);
                section.appendChild(card);
            });
        }

        if (!hasProducts && items.length === 0 && cat.isCustom) {
            const empty = document.createElement('div');
            empty.className = 'category-empty';
            empty.textContent = 'Sem itens nesta categoria.';
            section.appendChild(empty);
        }

        container.appendChild(section);
        container.appendChild(section);
    });
}

function renderBestSellers() {
    const container = document.getElementById('best-sellers-list');
    const section = document.getElementById('best-sellers-section');

    if (!container || !section) return;

    container.innerHTML = '';

    const bestSellers = [];
    const overrideItems = getBestSellersOverrideItems();
    const presetItems = getBestSellersPresetItems();
    const labeledPaths = (state.bestSellerPaths || []).filter(Boolean);

    if (overrideItems.length > 0) {
        bestSellers.push(...overrideItems);
    } else if (presetItems.length > 0) {
        bestSellers.push(...presetItems);
    } else {
        labeledPaths.forEach(path => {
            if (state.products[path]) {
                bestSellers.push(state.products[path]);
            }
        });
    }

    if (bestSellers.length === 0) {
        // Fallback: IDs extracted from the old reference snippet
        const bestSellerIds = [
            'Zqe3Jzv7DVksLovi9jLt', // Calota Especial
            'oZKhcwpFPIfsgUAMLbFo', // Calotinha Especial
            'YD2Zo70Sa1TGDAZYoelH', // MEGA COMBO
            'QWRGZwhaGaStSYnprUmT', // Calota Turbinado
            'G4j9G1gHVnbUmzRRXQxo'  // Calota Bacon c/ Catupiry
        ];

        const productPaths = Object.keys(state.products);

        bestSellerIds.forEach(id => {
            const path = productPaths.find(p => p.includes(id) && p.endsWith(id));
            if (path && state.products[path]) {
                bestSellers.push(state.products[path]);
            }
        });
    }

    if (bestSellers.length === 0) return;

    section.style.display = 'block';

    bestSellers.forEach((product, index) => {
        const card = createBestSellerCard(product, index);
        container.appendChild(card);
    });
}

function getBestSellersOverrideItems() {
    try {
        const raw = localStorage.getItem('menuBestSellersOverrides');
        if (!raw) return [];

        const data = JSON.parse(raw);
        if (!data || typeof data !== 'object') return [];

        const items = [];
        const paths = Array.isArray(data.paths) ? data.paths : [];
        const customItems = Array.isArray(data.customItems) ? data.customItems : [];

        paths.forEach(path => {
            const product = state.products[path];
            if (product) items.push(product);
        });

        customItems.forEach(entry => {
            let categoryId = entry?.categoryId;
            let itemId = entry?.itemId;

            if ((!categoryId || !itemId) && typeof entry?.key === 'string') {
                const parts = entry.key.split('::');
                if (parts.length === 2) {
                    [categoryId, itemId] = parts;
                }
            }

            if (!categoryId || !itemId) return;
            const list = state.customProducts?.[categoryId] || [];
            const item = list.find(p => p.id === itemId);
            if (item) items.push(item);
        });

        return items;
    } catch (e) {
        console.warn('menuBestSellersOverrides invÃ¡lido, ignorado.');
        return [];
    }
}

function getBestSellersPresetItems() {
    const presets = {
        'x-calota-brasil-ltda-jundiai': [
            'oZKhcwpFPIfsgUAMLbFo',
            'Zqe3Jzv7DVksLovi9jLt',
            'YD2Zo70Sa1TGDAZYoelH',
            'QWRGZwhaGaStSYnprUmT',
            'QNcktdX7xEkxHbU3bf4U'
        ]
    };

    const slug = state.store?.store?.menuSlug || state.store?.menuSlug || '';
    const ids = presets[slug] || [];
    if (ids.length === 0) return [];

    const productPaths = Object.keys(state.products);
    const items = [];
    ids.forEach(id => {
        const path = productPaths.find(p => p.endsWith(id));
        if (path && state.products[path]) {
            items.push(state.products[path]);
        }
    });

    return items;
}

function applyCategoryOverrides() {
    try {
        const raw = localStorage.getItem('menuCategoryOverrides');
        if (!raw) return;

        const overrides = JSON.parse(raw);
        const added = Array.isArray(overrides?.added) ? overrides.added : [];
        const updated = overrides?.updated && typeof overrides.updated === 'object' ? overrides.updated : {};
        const removed = Array.isArray(overrides?.removed) ? overrides.removed : [];
        const customProducts = overrides?.customProducts && typeof overrides.customProducts === 'object'
            ? overrides.customProducts
            : {};

        if (removed.length > 0) {
            state.categories = state.categories.filter(cat => !removed.includes(cat.id));
        }

        state.categories.forEach(cat => {
            const patch = updated[cat.id];
            if (patch && patch.name) {
                cat.name = patch.name;
            }
        });

        added.forEach(cat => {
            if (!cat || !cat.id) return;
            const exists = state.categories.some(existing => existing.id === cat.id);
            if (!exists) {
                state.categories.push(cat);
            }
        });

        state.customProducts = customProducts;
    } catch (e) {
        console.warn('menuCategoryOverrides invÃ¡lido, ignorado.');
    }
}

function createBestSellerCard(product, index) {
    const div = document.createElement('div');
    div.className = 'best-seller-card';
    div.onclick = () => openModal(product);

    const price = formatPrice(product.price);
    const imageUrl = getImageUrl(product.picture);

    // Garantir "A partir de" no modal para itens do carrossel
    product.forceFromLabel = true;

    // Only the first item gets the "Favorite" badge (index 0)
    const isFavorite = index === 0;

    div.innerHTML = `
        <div class="bs-image-container">
            ${isFavorite ? '<div class="bs-chip">ðŸ”¥ O favorito!</div>' : ''}
            <img src="${imageUrl}" class="bs-image" loading="lazy">
        </div>
        <div class="bs-info">
            <div class="bs-name" title="${product.name}">${product.name}</div>
            <div class="bs-price-label">A partir de</div>
            <div class="bs-price price-value">${price}</div>
        </div>
    `;

    return div;
}

function createProductCard(product, showFrom = false) {
    const div = document.createElement('div');
    div.className = 'product-card';
    div.onclick = () => openModal(product);

    const price = formatPrice(product.price);
    const imageUrl = getImageUrl(product.picture);
    const fromHtml = showFrom ? '<span class="from-price">A partir de</span>' : '';

    div.innerHTML = `
        <div class="product-info">
            <div class="product-name">${product.name}</div>
            <div class="product-desc">${product.description || ''}</div>
            <div class="product-price-wrapper">
                ${fromHtml}
                <span class="product-price price-value">${price}</span>
            </div>
        </div>
        ${imageUrl ? `<img src="${imageUrl}" class="product-image" loading="lazy" onerror="this.style.display='none'">` : ''}
    `;

    return div;
}

function scrollToCategory(catId) {
    const section = document.getElementById(`cat-${catId}`);
    if (section) {
        const offset = 120; // Match scroll spy offset
        const bodyRect = document.body.getBoundingClientRect().top;
        const elementRect = section.getBoundingClientRect().top;
        const elementPosition = elementRect - bodyRect;
        const offsetPosition = elementPosition - offset;

        window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth'
        });
    }
}

// Modal Logic
function openModal(product) {
    state.currentProduct = product;
    state.currentQty = 1;

    const contentId = getMetaContentId(product);
    trackMetaEvent('ViewContent', {
        content_ids: contentId ? [contentId] : undefined,
        content_name: product?.name || '',
        content_type: 'product',
        value: toMetaValue(product?.price || 0),
        currency: META_CURRENCY
    });

    document.getElementById('modal-title').textContent = product.name;
    document.getElementById('modal-desc').textContent = product.description || '';
    const modalPriceEl = document.getElementById('modal-price');
    const priceText = formatPrice(product.price);
    const shouldShowFrom = !!(product.showFrom || product.forceFromLabel);
    if (shouldShowFrom) {
        modalPriceEl.classList.add('with-from');
        modalPriceEl.innerHTML = `<div class="from-row"><span class="from-price">A partir de</span><span class="modal-price-value price-value">${priceText}</span></div><hr class="q-separator q-separator--horizontal q-separator--horizontal-inset" aria-orientation="horizontal" style="height: 1px;">`;
    } else {
        modalPriceEl.classList.remove('with-from');
        modalPriceEl.innerHTML = `<span class="price-value">${priceText}</span>`;
    }
    document.getElementById('qty-value').value = 1;
    document.getElementById('observation').value = '';

    const img = document.getElementById('modal-img');
    if (product.picture) {
        img.src = getImageUrl(product.picture);
        img.style.display = 'block';
    } else {
        img.style.display = 'none';
    }

    syncCokeSelectionFromItem(product);
    updateModalTotal();

    // Handle Add-ons Visibility
    const addonsSection = document.querySelector('.addons-section');
    const addonsSearch = document.querySelector('.addons-search-container');

    if (product.hasAddons || shouldShowFrom) {
        addonsSection.style.display = 'block';
        addonsSearch.style.display = 'block';
        renderAddons();
    } else {
        addonsSection.style.display = 'none';
        addonsSearch.style.display = 'none';
        selectedAddons.clear(); // Clear selections if hidden
    }

    renderCokeOptions(product);

    document.getElementById('product-modal').classList.add('active');
    document.body.style.overflow = 'hidden'; // Lock scroll
}

// Add-ons Data
const addonsData = [
    { id: 'add-1', name: 'HambÃºrguer (1 Unidade)', desc: '1 Unidade.', price: 900, image: 'https://firebasestorage.googleapis.com/v0/b/brendi-app.appspot.com/o/stores%2FNGfho4kycwo6LXqg6vkW%2Fproducts%2FZqe3Jzv7DVksLovi9jLt%2Fimage.jpeg?alt=media' }, // Using generic or specific image if available
    { id: 'add-2', name: 'Alcatra (60 g)', desc: '60 g.', price: 1400, image: '' },
    { id: 'add-3', name: 'Bacon (80 g)', desc: '80 g.', price: 600, image: '' },
    { id: 'add-4', name: 'Catupiry', desc: '', price: 600, image: '' },
    { id: 'add-5', name: 'Cebola', desc: '', price: 200, image: '' },
    { id: 'add-6', name: 'Cheddar', desc: '', price: 600, image: '' },
    { id: 'add-7', name: 'CoraÃ§Ã£o (90 g)', desc: '90 g.', price: 1000, image: '' },
    { id: 'add-8', name: 'Frango (90 g)', desc: '90 g.', price: 900, image: '' },
    { id: 'add-9', name: 'Ovo (1 Unidade)', desc: '1 Unidade', price: 300, image: '' },
    { id: 'add-10', name: 'Queijo (1 Fatia)', desc: '1 Fatia', price: 400, image: '' },
    { id: 'add-11', name: 'Presunto (1 fatia)', desc: '', price: 500, image: '' }
];

let selectedAddons = new Map();
let selectedCokeOption = null;

const cokeOptionsData = [
    {
        id: 'coke-zero',
        name: 'Coca Cola Zero',
        price: 0,
        image: ''
    },
    {
        id: 'coke-original',
        name: 'Coca Cola Original',
        price: 0,
        image: ''
    }
];

function shouldShowCokeOptions(product) {
    const name = product?.name || '';
    return /coca\s*cola|\bcoca\b/i.test(name);
}

function syncCokeSelectionFromItem(product) {
    selectedCokeOption = null;
    const addons = Array.isArray(product?.addons) ? product.addons : [];
    const match = addons.find(addon => addon && (addon.id === 'coke-zero' || addon.id === 'coke-original' || /coca\s*cola|\bcoca\b/i.test(addon.name || '')));
    if (!match) return;

    if (match.id === 'coke-zero' || match.id === 'coke-original') {
        selectedCokeOption = match.id;
        return;
    }

    const name = (match.name || '').toLowerCase();
    selectedCokeOption = name.includes('zero') ? 'coke-zero' : 'coke-original';
}

function getSelectedCokeOption() {
    if (!state.currentProduct) return null;
    if (!shouldShowCokeOptions(state.currentProduct)) return null;
    const selectedId = selectedCokeOption || 'coke-original';
    return cokeOptionsData.find(option => option.id === selectedId) || null;
}

function renderCokeOptions(product) {
    const container = document.getElementById('coke-options');
    const list = document.getElementById('coke-list');
    if (!container || !list) return;

    if (!shouldShowCokeOptions(product)) {
        container.style.display = 'none';
        list.innerHTML = '';
        selectedCokeOption = null;
        return;
    }

    container.style.display = 'block';
    list.innerHTML = '';
    selectedCokeOption = selectedCokeOption || 'coke-original';

    cokeOptionsData.forEach(option => {
        const row = document.createElement('div');
        row.className = 'coke-item';

        const priceText = option.price ? `+ ${formatPrice(option.price)}` : '';
        row.innerHTML = `
            <div class="coke-info">
                <div class="coke-name">${option.name}</div>
                <div class="coke-price">${priceText}</div>
            </div>
            ${option.image ? `<img class="coke-thumb" src="${option.image}" alt="${option.name}">` : '<span class="coke-thumb-spacer" aria-hidden="true"></span>'}
            <label class="coke-radio">
                <input type="radio" name="coke-option" value="${option.id}" ${selectedCokeOption === option.id ? 'checked' : ''}>
            </label>
        `;

        row.querySelector('input')?.addEventListener('change', () => {
            selectedCokeOption = option.id;
        });

        list.appendChild(row);
    });
}

function getAddonsLimit() {
    const chip = document.querySelector('.addons-limit-chip');
    if (!chip) return 3;
    const match = chip.textContent.match(/\d+/);
    return match ? Number(match[0]) : 3;
}

function getAddonsTotalQty() {
    let total = 0;
    selectedAddons.forEach(entry => {
        total += entry.qty || 0;
    });
    return total;
}

function shakeAddonsLimitChip() {
    const chip = document.querySelector('.addons-limit-chip');
    if (!chip) return;
    chip.classList.remove('addons-limit-chip--shake');
    void chip.offsetWidth;
    chip.classList.add('addons-limit-chip--shake');
}

function renderAddons(filterText = '') {
    const list = document.getElementById('addons-list');
    list.innerHTML = '';
    selectedAddons.clear(); // Reset selection on re-open or handle state persistence if needed. For now reset. (Or move clearing to closeModal)

    // For images, since I don't have all URLs, I'll use placeholders or try to match product images if roughly similar, or leave blank/icon.
    // The reference showed specific images. I'll use a placeholder icon logic if empty.

    const filtered = addonsData.filter(item => item.name.toLowerCase().includes(filterText.toLowerCase()));

    filtered.forEach(addon => {
        const item = document.createElement('div');
        item.className = 'addon-item';
        item.onclick = (e) => toggleAddon(addon, item);

        const priceStr = `+ ${formatPrice(addon.price)}`;

        item.innerHTML = `
            <div class="addon-info">
                <div class="addon-name">${addon.name}</div>
                <div class="addon-desc">${addon.description || addon.desc || ''}</div>
                <div class="addon-price price-value">${priceStr}</div>
            </div>
            <div class="addon-right">
                <div class="addon-check">
                    <i class="fas fa-plus"></i>
                </div>
            </div>
        `;
        list.appendChild(item);
    });
}

function toggleAddon(addon, element) {
    if (selectedAddons.has(addon.id)) {
        selectedAddons.delete(addon.id);
        element.classList.remove('selected');
        renderAddonControl(addon, element);
        updateModalTotal();
        return;
    }

    const limit = getAddonsLimit();
    if (getAddonsTotalQty() + 1 > limit) {
        shakeAddonsLimitChip();
        return;
    }

    selectedAddons.set(addon.id, { addon, qty: 1 });
    element.classList.add('selected');
    renderAddonControl(addon, element);
    updateModalTotal();
}

function renderAddonControl(addon, element) {
    const right = element.querySelector('.addon-right');
    const selected = selectedAddons.get(addon.id);

    if (!selected) {
        right.innerHTML = `
            <div class="addon-check">
                <i class="fas fa-plus"></i>
            </div>
        `;
        return;
    }

    right.innerHTML = `
        <div class="addon-qty-control">
            <button class="addon-qty-btn" data-action="decrease" aria-label="Diminuir">
                <i class="fas fa-minus"></i>
            </button>
            <span class="addon-qty-value">${selected.qty}</span>
            <button class="addon-qty-btn" data-action="increase" aria-label="Aumentar">
                <i class="fas fa-plus"></i>
            </button>
        </div>
    `;

    right.querySelectorAll('.addon-qty-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = btn.getAttribute('data-action');
            const current = selectedAddons.get(addon.id);
            if (!current) return;

            let nextQty = current.qty + (action === 'increase' ? 1 : -1);
            if (nextQty <= 0) {
                selectedAddons.delete(addon.id);
                element.classList.remove('selected');
                renderAddonControl(addon, element);
                updateModalTotal();
                return;
            }

            if (action === 'increase') {
                const limit = getAddonsLimit();
                if (getAddonsTotalQty() + 1 > limit) {
                    shakeAddonsLimitChip();
                    return;
                }
            }

            current.qty = nextQty;
            const qtyEl = element.querySelector('.addon-qty-value');
            if (qtyEl) qtyEl.textContent = String(nextQty);
            updateModalTotal();
        });
    });
}

// Add search listener
document.getElementById('addons-search-input').addEventListener('input', (e) => {
    // Current selection state is lost if we re-render entirely. 
    // To fix: separate render from selection state logic or simple hide/show.
    // For simplicity, hide/show based on class
    const filter = e.target.value.toLowerCase();
    const items = document.querySelectorAll('.addon-item');
    items.forEach(el => {
        const name = el.querySelector('.addon-name').textContent.toLowerCase();
        el.style.display = name.includes(filter) ? 'flex' : 'none';
    });
});

function closeModal() {
    document.getElementById('product-modal').classList.remove('active');
    document.body.style.overflow = '';
}

function updateModalTotal() {
    if (!state.currentProduct) return;

    let addonsTotal = 0;
    selectedAddons.forEach(entry => {
        addonsTotal += entry.addon.price * entry.qty;
    });

    const cokeOption = getSelectedCokeOption();
    if (cokeOption) {
        addonsTotal += cokeOption.price || 0;
    }

    const total = (state.currentProduct.price + addonsTotal) * state.currentQty;
    const btn = document.getElementById('modal-total-price');
    btn.textContent = formatPrice(total);
}

// Cart Logic
function addToCart() {
    if (!state.currentProduct) return;

    const addonsList = Array.from(selectedAddons.values()).map(entry => ({
        ...entry.addon,
        qty: entry.qty
    }));

    const cokeOption = getSelectedCokeOption();
    if (cokeOption) {
        addonsList.push({
            id: cokeOption.id,
            name: cokeOption.name,
            price: cokeOption.price || 0,
            qty: 1
        });
    }

    const item = {
        ...state.currentProduct,
        qty: state.currentQty,
        obs: document.getElementById('observation').value,
        addons: addonsList,
        totalPrice: (state.currentProduct.price + addonsList.reduce((sum, a) => sum + (a.price * a.qty), 0)) * state.currentQty
    };

    state.cart.push(item);
    writeCartStorage(state.cart);
    updateCartFooter();
    const contentId = getMetaContentId(item);
    trackMetaEvent('AddToCart', {
        content_ids: contentId ? [contentId] : undefined,
        content_name: item?.name || '',
        content_type: 'product',
        value: toMetaValue(item?.totalPrice || 0),
        currency: META_CURRENCY,
        contents: buildMetaContents([item])
    });
    closeModal();
}

function updateCartFooter() {
    const footer = document.getElementById('cart-footer');
    const countVal = document.getElementById('cart-count-value');
    const totalVal = document.getElementById('cart-total-value');

    if (state.cart.length > 0) {
        footer.classList.add('visible');
        // const count = state.cart.reduce((acc, item) => acc + item.qty, 0); // Count badge removed
        const total = state.cart.reduce((acc, item) => acc + item.totalPrice, 0);

        // countVal.textContent = count; // Removed
        totalVal.textContent = formatPrice(total);
    } else {
        footer.classList.remove('visible');
    }
}

function finishOrder() {
    const total = (state.cart || []).reduce((acc, item) => acc + (item?.totalPrice || 0), 0);
    trackMetaEvent('InitiateCheckout', {
        value: toMetaValue(total),
        currency: META_CURRENCY,
        contents: buildMetaContents(state.cart),
        num_items: (state.cart || []).reduce((acc, item) => acc + (item?.qty || 0), 0)
    });
    const raw = JSON.stringify(state.cart || []);
    const encoded = encodeURIComponent(raw);
    const target = encoded.length ? `checkout.html?cart=${encoded}` : 'checkout.html';
    window.location.href = target;
}

// Helpers
function getImageUrl(path) {
    if (!path) return null;
    if (path.startsWith('http')) return path;

    // Base Firebase Storage URL for Brendi app
    const baseUrl = "https://firebasestorage.googleapis.com/v0/b/brendi-app.appspot.com/o/";
    const encodedPath = encodeURIComponent(path);
    return `${baseUrl}${encodedPath}?alt=media`;
}

function formatPrice(val) {
    return (val / 100).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
}

function setupEventListeners() {
    document.getElementById('close-modal').onclick = closeModal;

    const shareBtn = document.getElementById('share-modal');
    if (shareBtn) {
        shareBtn.onclick = shareCurrentProduct;
    }

    document.getElementById('qty-minus').onclick = () => {
        if (state.currentQty > 1) {
            state.currentQty--;
            document.getElementById('qty-value').value = state.currentQty;
            updateModalTotal();
        }
    };

    document.getElementById('qty-plus').onclick = () => {
        state.currentQty++;
        document.getElementById('qty-value').value = state.currentQty;
        updateModalTotal();
    };

    const qtyInput = document.getElementById('qty-value');
    if (qtyInput) {
        qtyInput.addEventListener('input', () => {
            const parsed = parseInt(qtyInput.value, 10);
            if (Number.isNaN(parsed) || parsed < 1) {
                state.currentQty = 1;
                qtyInput.value = 1;
            } else {
                state.currentQty = parsed;
            }
            updateModalTotal();
        });

        qtyInput.addEventListener('blur', () => {
            if (!qtyInput.value || parseInt(qtyInput.value, 10) < 1) {
                state.currentQty = 1;
                qtyInput.value = 1;
                updateModalTotal();
            }
        });
    }

    document.getElementById('add-to-cart-btn').onclick = addToCart;
    document.getElementById('finish-order-btn').onclick = finishOrder;

    setupSearch();
    setupNavArrows();
    setupCategoryMenu();

    // Close modal on outside click
    document.getElementById('product-modal').onclick = (e) => {
        if (e.target.id === 'product-modal') closeModal();
    };

    // Scroll Listener for Sticky Nav
    // Scroll Listener for Sticky Nav & Search
    window.addEventListener('scroll', () => {
        const nav = document.getElementById('category-nav');
        const searchBar = document.getElementById('sticky-search-bar');
        const trigger = document.getElementById('best-sellers-section');

        let searchVisible = false;

        // Sticky Search Logic (Show easier, e.g. after header scroll)
        if (window.scrollY > 60) {
            searchBar.classList.add('visible');
            searchVisible = true;
        } else {
            searchBar.classList.remove('visible');
        }

        // Sticky Category Nav Logic
        if (trigger) {
            const rect = trigger.getBoundingClientRect();
            // Show when the top of the best sellers section scrolls under the top of the viewport
            // (i.e. user scrolled DOWN past the start of it)

            // Adjust trigger logic: Maybe show a bit earlier or same?
            // User said "aparece antes" for search. We got that (scrolly > 60).
            // Nav shows when content starts.

            if (rect.top <= 80) { // Slightly looser threshold so it appears as we approach?
                nav.classList.add('visible');

                if (searchVisible) {
                    nav.classList.add('shifted');
                } else {
                    nav.classList.remove('shifted');
                }
            } else {
                nav.classList.remove('visible');
                nav.classList.remove('shifted');
            }
        }

        updateActiveCategory();
    });
}

function updateActiveCategory() {
    if (isNavClicking) return; // Skip update if scrolling from click

    // Include the best sellers section in the spy list
    const sections = document.querySelectorAll('#best-sellers-section, .category-section');
    const navItems = document.querySelectorAll('.category-item');

    let currentId = '';
    const offset = 120;

    sections.forEach(section => {
        // Only consider if visible
        if (section.style.display === 'none') return;

        const sectionTop = section.offsetTop;
        if (window.scrollY >= (sectionTop - offset)) {
            currentId = section.getAttribute('id');
        }
    });

    if (currentId) {
        navItems.forEach(li => {
            li.classList.remove('active');
            if (li.dataset.target === currentId) {
                li.classList.add('active');
                scrollToActiveNav(li);
            }
        });
    }
}

// Nav Arrows Logic
function setupNavArrows() {
    const leftBtn = document.getElementById('nav-arrow-left');
    const rightBtn = document.getElementById('nav-arrow-right');
    const scrollContainer = document.getElementById('category-scroll-container');

    if (!scrollContainer) return;

    let scrollInterval;
    let isHolding = false;
    let holdStartTime;

    const startScrolling = (direction) => {
        isHolding = true;
        holdStartTime = Date.now();
        clearInterval(scrollInterval);
        setTimeout(() => {
            if (isHolding) {
                scrollInterval = setInterval(() => {
                    scrollContainer.scrollLeft += (direction * 10);
                }, 16);
            }
        }, 200);
    };

    const stopScrolling = (direction) => {
        if (!isHolding) return;
        isHolding = false;
        clearInterval(scrollInterval);
        if (Date.now() - holdStartTime < 200) stepScroll(direction);
    };

    const stepScroll = (direction) => {
        const containerCenter = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2);
        const items = Array.from(document.querySelectorAll('.category-item'));
        let minDiff = Infinity;
        let closestIndex = 0;
        items.forEach((item, index) => {
            const diff = Math.abs(containerCenter - (item.offsetLeft + item.clientWidth / 2));
            if (diff < minDiff) { minDiff = diff; closestIndex = index; }
        });

        let targetIndex = closestIndex + (direction > 0 ? 1 : -1);
        if (targetIndex < 0) targetIndex = 0;
        if (targetIndex >= items.length) targetIndex = items.length - 1;
        scrollToActiveNav(items[targetIndex]);
    };

    leftBtn.onpointerdown = (e) => { e.preventDefault(); startScrolling(-1); };
    leftBtn.onpointerup = () => stopScrolling(-1);
    leftBtn.onpointerleave = () => { isHolding = false; clearInterval(scrollInterval); };

    rightBtn.onpointerdown = (e) => { e.preventDefault(); startScrolling(1); };
    rightBtn.onpointerup = () => stopScrolling(1);
    rightBtn.onpointerleave = () => { isHolding = false; clearInterval(scrollInterval); };

    // Optional: Hide arrows if at ends. Add scroll listener to container.
    const updateArrows = () => {
        // Simple logic: if scrollLeft > 0 show left. 
        // If scrollLeft + width < scrollWidth show right.
        if (scrollContainer.scrollLeft > 10) {
            leftBtn.style.opacity = '1';
            leftBtn.style.pointerEvents = 'auto';
        } else {
            leftBtn.style.opacity = '0';
            leftBtn.style.pointerEvents = 'none';
        }

        if (scrollContainer.scrollLeft + scrollContainer.clientWidth < scrollContainer.scrollWidth - 10) {
            rightBtn.style.opacity = '1';
            rightBtn.style.pointerEvents = 'auto';
        } else {
            rightBtn.style.opacity = '0';
            rightBtn.style.pointerEvents = 'none';
        }
    };

    scrollContainer.addEventListener('scroll', updateArrows);
    // Initial check
    updateArrows();
}

function setupCategoryMenu() {
    const openBtn = document.getElementById('open-category-menu');
    const overlay = document.getElementById('category-menu-overlay');
    const list = document.getElementById('category-menu-list');
    const closeBtn = document.getElementById('category-menu-close');

    if (!openBtn || !overlay || !list) return;

    const scrollToTarget = (targetId) => {
        const section = document.getElementById(targetId);
        if (!section) return;

        const offset = 120;
        const bodyRect = document.body.getBoundingClientRect().top;
        const elementRect = section.getBoundingClientRect().top;
        const elementPosition = elementRect - bodyRect;
        const offsetPosition = elementPosition - offset;
        window.scrollTo({ top: offsetPosition, behavior: 'smooth' });
    };

    const closeMenu = () => {
        overlay.classList.remove('active');
        overlay.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('no-scroll');
    };

    const buildList = () => {
        list.innerHTML = '';

        const addItem = (label, targetId) => {
            const item = document.createElement('li');
            item.className = 'category-menu-item';
            item.setAttribute('role', 'listitem');
            item.setAttribute('tabindex', '0');
            item.dataset.target = targetId;
            item.textContent = label;

            item.addEventListener('click', () => {
                isNavClicking = true;
                scrollToTarget(targetId);
                document.querySelectorAll('.category-menu-item').forEach(el => el.classList.remove('active'));
                item.classList.add('active');
                closeMenu();
                setTimeout(() => { isNavClicking = false; }, 2000);
            });

            item.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    item.click();
                }
            });

            list.appendChild(item);
        };

        const bestSection = document.getElementById('best-sellers-section');
        if (bestSection && bestSection.style.display !== 'none') {
            addItem('Mais Pedidos', 'best-sellers-section');
        }

        state.categories.forEach(cat => {
            if (!cat.productsPaths || cat.productsPaths.length === 0) return;
            addItem(cat.name, `cat-${cat.id}`);
        });
    };

    const openMenu = () => {
        buildList();
        overlay.classList.add('active');
        overlay.setAttribute('aria-hidden', 'false');
        document.body.classList.add('no-scroll');
    };

    openBtn.addEventListener('click', openMenu);
    if (closeBtn) closeBtn.addEventListener('click', closeMenu);

    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeMenu();
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && overlay.classList.contains('active')) {
            closeMenu();
        }
    });
}

function scrollToActiveNav(activeItem) {
    const navById = document.getElementById('category-scroll-container'); // Updated ID
    if (!navById) return;

    const navWidth = navById.clientWidth;
    const itemLeft = activeItem.offsetLeft;
    const itemWidth = activeItem.clientWidth;
    const scrollPos = itemLeft - (navWidth / 2) + (itemWidth / 2) - 60;

    navById.scrollTo({ left: scrollPos, behavior: 'smooth' });
}

// Search Logic
function setupSearch() {
    const searchInputs = document.querySelectorAll('.search-input-field, .search-input, #new-search-input');
    const overlay = document.getElementById('search-overlay-container');
    const closeBtn = document.getElementById('close-search-btn');
    const triggerBtns = document.querySelectorAll('.search-btn'); // Header button

    // Existing input listener logic
    searchInputs.forEach(input => {
        input.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            filterProducts(query);

            // Sync other inputs if needed, or at least clear them if this is a global search
            searchInputs.forEach(other => {
                if (other !== input) other.value = input.value;
            });
        });
    });

    // Toggle Overlay on trigger click
    triggerBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Check if visible
            const isVisible = overlay.classList.contains('visible');

            if (!isVisible) {
                overlay.style.display = 'block'; // Remove inline display:none
                // specific timeout to allow browser paint before adding class for transition
                requestAnimationFrame(() => {
                    overlay.classList.add('visible');
                });
                document.getElementById('new-search-input')?.focus();
            } else {
                overlay.classList.remove('visible');
                // Wait for transition (600ms) before hiding display
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 600);
            }
        });
    });

    // Close Overlay
    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            overlay.classList.remove('visible');
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 600);
        });
    }
}

function filterProducts(query) {
    const sections = document.querySelectorAll('.category-section');

    sections.forEach(section => {
        const products = section.querySelectorAll('.product-card');
        let hasVisibleProduct = false;

        products.forEach(card => {
            const name = card.querySelector('.product-name').textContent.toLowerCase();
            const desc = card.querySelector('.product-desc')?.textContent.toLowerCase() || '';

            if (name.includes(query) || desc.includes(query)) {
                card.style.display = 'flex';
                hasVisibleProduct = true;
            } else {
                card.style.display = 'none';
            }
        });

        if (hasVisibleProduct) {
            section.style.display = 'block';
        } else {
            section.style.display = 'none';
        }
    });

    const bestSellers = document.getElementById('best-sellers-section');
    if (bestSellers) {
        if (query.length > 0) {
            bestSellers.style.display = 'none';
        } else {
            bestSellers.style.display = 'block';
        }
    }
}

// Cart Modal Logic

function openCart() {
    renderCartItems();
    document.getElementById("cart-modal").classList.add("active");
    document.body.style.overflow = "hidden";
}

function closeCart() {
    document.getElementById("cart-modal").classList.remove("active");
    document.body.style.overflow = "";
}

function renderCartItems() {
    const list = document.getElementById("cart-items-list");
    const emptyState = document.getElementById("cart-empty-state");
    const totalEl = document.getElementById("cart-modal-total");

    // Clear list but keep empty state element reference (or just rebuild)
    list.innerHTML = "";

    if (state.cart.length === 0) {
        list.appendChild(emptyState);
        emptyState.style.display = "flex";
        totalEl.textContent = "R$ 0,00";
        return;
    }

    emptyState.style.display = "none";
    list.appendChild(emptyState); // Keep it there hidden

    let total = 0;

    const formatAddonDisplay = (addon) => {
        const qty = addon?.qty || 1;
        let name = addon?.name || '';
        if (qty > 1) {
            name = name.replace(/\s*\(?1\s*unidade\)?\s*$/i, '').trim();
            return `${qty}x ${name}`;
        }
        return name;
    };

    state.cart.forEach((item, index) => {
        total += item.totalPrice;

        const div = document.createElement("div");
        div.className = "cart-item";

        // Addons Text
        let addonsText = "";
        if (item.addons && item.addons.length > 0) {
            addonsText = item.addons.map(a => `+ ${formatAddonDisplay(a)}`).join(", ");
        }

        div.innerHTML = `
            <div class="cart-item-header">
                <div class="cart-item-info">
                    <div class="cart-item-name">${item.qty}x ${item.name}</div>
                    ${item.obs ? `<div class="cart-item-obs">Obs: ${item.obs}</div>` : ""}
                    ${addonsText ? `<div class="cart-item-addons">${addonsText}</div>` : ""}
                </div>
                <div class="cart-item-price price-value">${formatPrice(item.totalPrice)}</div>
            </div>
            <div class="cart-item-footer">
                <button class="cart-remove-btn" onclick="removeCartItem(${index})">
                    <i class="fas fa-trash"></i> Remover
                </button>
                <!-- Optional: Add qty controls here if needed later -->
            </div>
        `;

        list.appendChild(div);
    });

    totalEl.textContent = formatPrice(total);
}

function removeCartItem(index) {
    state.cart.splice(index, 1);
    renderCartItems();
    updateCartFooter(); // Update sticky footer too
}

function checkout() {
    if (state.cart.length === 0) {
        alert("Sua sacola estï¿½ vazia!");
        return;
    }

    // Reuse existing logic or build new
    let msg = "*Novo Pedido X Calota*\n----------------\n";
    let total = 0;

    state.cart.forEach(item => {
        msg += `${item.qty}x ${item.name}\n`;
        if (item.addons && item.addons.length > 0) {
            const addonsStr = item.addons.map(a => formatAddonDisplay(a)).join(", ");
            msg += `   + ${addonsStr}\n`;
        }
        if (item.obs) msg += `   Obs: ${item.obs}\n`;
        msg += `   Valor: ${formatPrice(item.totalPrice)}\n\n`;
        total += item.totalPrice;
    });

    msg += "----------------\n";
    msg += `*Total: ${formatPrice(total)}*`;

    // Add address info if we had it, but for now just product list

    const encoded = encodeURIComponent(msg);
    const phone = "5533988025484"; // Updated to number from context file
    window.open(`https://wa.me/${phone}?text=${encoded}`, "_blank");
}
// Make functions global for inline onclick handlers
window.removeCartItem = removeCartItem;


/* Product Builder Logic - Appended */

const productCustoms = {
    "bebidas_combo": {
        id: "bebidas_combo",
        title: "Escolha sua Bebida",
        min: 1,
        max: 1,
        required: true,
        choices: [
            { id: "coca", name: "Coca Cola Original 350ml", price: 0 },
            { id: "coca_zero", name: "Coca Cola Zero 350ml", price: 0 },
            { id: "sprite", name: "Sprite 350ml", price: 0 },
            { id: "kuat", name: "Kuat GuaranÃ¡ 350ml", price: 0 },
            { id: "agua_sem_gas", name: "Ãgua Crystal S/ GÃ¡s", price: 0 },
            { id: "agua_com_gas", name: "Ãgua Crystal C/ GÃ¡s", price: 0 }
        ]
    },
    "acompanhamento_combo": {
        id: "acompanhamento_combo",
        title: "Escolha seu Acompanhamento",
        min: 1,
        max: 1,
        required: true,
        choices: [
            { id: "fritas", name: "Batata Frita", price: 0 },
            { id: "chips", name: "Chips de Batata Doce", price: 0 },
            { id: "bolinho", name: "Bolinho de Pulled Pork (2un)", price: 400 }
        ]
    },
    "adicionais_burger": {
        id: "adicionais_burger",
        title: "Turbine seu Burger",
        min: 0,
        max: 5,
        required: false,
        choices: [
            { id: "bacon", name: "Bacon Extra", price: 600 },
            { id: "cheddar", name: "Cheddar Extra", price: 500 },
            { id: "caramelizada", name: "Cebola Caramelizada", price: 500 },
            { id: "maionese", name: "Maionese da Casa", price: 350 }
        ]
    }
};

let currentBuilderProduct = null;
let currentBuilderQty = 1;
let currentBuilderDo = {}; // selected options: { groupId: [choiceId, choiceId] }

function getProductCustoms(product) {
    const list = [];
    if (product.name.includes("Combo") || product.name.includes("Handmade")) {
        // Assume combos have drinks and sides logic if mostly true
        if (!product.name.includes("Burger")) list.push("bebidas_combo", "acompanhamento_combo");
    }
    // All burgers can have add-ons
    if (product.name.includes("Burger") || product.name.includes("Handmade")) {
        list.push("adicionais_burger");
    }
    return list;
}

function openProductBuilder(product) {
    currentBuilderProduct = product;
    currentBuilderQty = 1;
    currentBuilderDo = {};

    // UI Reset
    document.getElementById("builder-image").src = getImageUrl(product.picture);
    document.getElementById("builder-title").textContent = product.name;
    document.getElementById("builder-desc").textContent = product.description || "";
    document.getElementById("builder-qty").textContent = "1";

    const container = document.getElementById("builder-options-container");
    container.innerHTML = "";

    const customIds = getProductCustoms(product);

    if (customIds.length === 0) {
        // Fallback for simple products
        // We could just add directly, but for consistency let show modal with no options
        // or Just render "Quantiy"
    }

    customIds.forEach(id => {
        const group = productCustoms[id];
        if (!group) return;

        // Init selected state
        currentBuilderDo[id] = [];

        const groupDiv = document.createElement("div");
        groupDiv.className = "option-group";

        const requiredBadge = group.required ? `<span class="option-group-limits required">ObrigatÃ³rio</span>` : "";
        const limitText = group.max > 1 ? `Escolha atÃ© ${group.max}` : `Escolha 1`;

        groupDiv.innerHTML = `
            <div class="option-group-header">
                <div class="option-group-title">${group.title}</div>
                <div>
                   ${requiredBadge}
                   <span class="option-group-limits">${limitText}</span>
                </div>
            </div>
        `;

        group.choices.forEach(choice => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "option-item";
            itemDiv.onclick = (e) => toggleOption(id, choice.id, group.max, group.type);

            const inputType = group.max === 1 ? "radio" : "checkbox";
            const priceText = choice.price > 0 ? `+ ${formatPrice(choice.price)}` : "GrÃ¡tis";

            itemDiv.innerHTML = `
                <div class="option-label">
                    <div class="option-input" type="${inputType}" id="opt-${id}-${choice.id}"></div>
                    <span>${choice.name}</span>
                </div>
                <div class="option-price price-value">${priceText}</div>
            `;
            groupDiv.appendChild(itemDiv);
        });

        container.appendChild(groupDiv);
    });

    updateBuilderTotal();

    const modal = document.getElementById("product-builder-modal");
    modal.classList.add("active");
    modal.style.display = "flex"; // Ensure flex for centering
}

function toggleOption(groupId, choiceId, max, type) {
    const selected = currentBuilderDo[groupId];
    const index = selected.indexOf(choiceId);

    if (max === 1) {
        // Radio behavior
        currentBuilderDo[groupId] = [choiceId];
        // Visual Update All in Group
        document.querySelectorAll(`[id^="opt-${groupId}-"]`).forEach(el => {
            el.checked = false;
            el.setAttribute("checked", "false"); // for CSS styling helper if needed
            el.style.borderColor = "#444";
            el.innerHTML = "";
        });
        const active = document.getElementById(`opt-${groupId}-${choiceId}`);
        active.style.borderColor = "#54cc63";
        active.innerHTML = `<div style="width:10px;height:10px;background:#54cc63;border-radius:50%"></div>`; // Simple manual check
    } else {
        // Checkbox behavior
        if (index > -1) {
            selected.splice(index, 1);
            // Uncheck visual
            const el = document.getElementById(`opt-${groupId}-${choiceId}`);
            el.innerHTML = "";
            el.style.borderColor = "#444";
        } else {
            if (selected.length < max) {
                selected.push(choiceId);
                const el = document.getElementById(`opt-${groupId}-${choiceId}`);
                el.innerHTML = `<div style="width:10px;height:10px;background:#54cc63;border-radius:2px"></div>`;
                el.style.borderColor = "#54cc63";
            }
        }
    }
    updateBuilderTotal();
}

function updateBuilderQty(change) {
    const newQty = currentBuilderQty + change;
    if (newQty < 1) return;
    currentBuilderQty = newQty;
    document.getElementById("builder-qty").textContent = currentBuilderQty;
    updateBuilderTotal();
}

function updateBuilderTotal() {
    let total = currentBuilderProduct.price;

    // Add options
    const customIds = getProductCustoms(currentBuilderProduct);
    let allRequiredMet = true;

    customIds.forEach(gid => {
        const group = productCustoms[gid];
        const selectedIds = currentBuilderDo[gid] || [];

        if (group.required && selectedIds.length < group.min) {
            allRequiredMet = false;
        }

        selectedIds.forEach(cid => {
            const choice = group.choices.find(c => c.id === cid);
            if (choice) total += choice.price;
        });
    });

    const finalTotal = total * currentBuilderQty;
    document.getElementById("builder-total-price").textContent = formatPrice(finalTotal);
    document.getElementById("builder-base-price").textContent = formatPrice(currentBuilderProduct.price);

    document.getElementById("add-to-order-btn").disabled = !allRequiredMet;
}

document.getElementById("close-builder-modal").onclick = () => {
    document.getElementById("product-builder-modal").classList.remove("active");
    document.body.style.overflow = ""; // restore scroll
}

document.getElementById("add-to-order-btn").onclick = () => {
    // Build complex cart item
    const addons = [];
    Object.keys(currentBuilderDo).forEach(gid => {
        const selectedIds = currentBuilderDo[gid];
        const group = productCustoms[gid];
        selectedIds.forEach(cid => {
            const choice = group.choices.find(c => c.id === cid);
            if (choice) addons.push({ group: group.title, name: choice.name, price: choice.price });
        });
    });

    // Calculate single unit price with addons
    let unitPrice = currentBuilderProduct.price;
    addons.forEach(a => unitPrice += a.price);

    const cartItem = {
        ...currentBuilderProduct,
        qty: currentBuilderQty,
        addons: addons,
        unitPriceWithAddons: unitPrice,
        totalPrice: unitPrice * currentBuilderQty
    };

    state.cart.push(cartItem);
    updateCartCounter();

    // Close modal
    document.getElementById("product-builder-modal").classList.remove("active");
    document.body.style.overflow = "";

    // Feedback
    // Maybe open cart?
    openCart();
};


